<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>La Catrina - Pool League 3D</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            overflow: hidden;
            position: relative;
        }

        /* Fondo del bar */
        .bar-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(0,0,0,0.7), rgba(0,0,0,0.7)), 
                        url('material/imagen2.jpeg') center/cover;
            z-index: -1;
        }

        /* Canvas 3D */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI Overlay */
        .ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
        }

        .header {
            text-align: center;
            padding: 2rem;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, transparent 100%);
        }

        .header h1 {
            font-family: 'Georgia', serif;
            font-size: 3rem;
            color: #d4af37;
            text-shadow: 0 0 30px rgba(212, 175, 55, 0.8);
            letter-spacing: 8px;
            text-transform: uppercase;
        }

        .header p {
            color: #888;
            font-size: 0.9rem;
            letter-spacing: 4px;
            margin-top: 0.5rem;
        }

        /* Marcadores de troneras (posicionados sobre el canvas) */
        .pocket-marker {
            position: absolute;
            width: 60px;
            height: 60px;
            cursor: pointer;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            transition: transform 0.3s ease;
            z-index: 100;
        }

        .pocket-marker:hover {
            transform: scale(1.2);
        }

        .pocket-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #d4af37;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s ease;
            top: 70px;
            pointer-events: none;
            border: 1px solid #d4af37;
        }

        .pocket-marker:hover .pocket-label {
            opacity: 1;
        }

        /* Indicador de carga */
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #d4af37;
            font-size: 1.5rem;
            z-index: 1000;
        }

        /* Instrucciones */
        .instructions {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #888;
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 0.8rem;
            letter-spacing: 2px;
            border: 1px solid rgba(212, 175, 55, 0.3);
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="bar-bg"></div>
    <div id="loading">Cargando...</div>
    <div id="canvas-container"></div>
    
    <div class="ui-layer">
        <div class="header">
            <h1>LA CATRINA</h1>
            <p>POOL LEAGUE & BILLIARDS</p>
        </div>
    </div>

    <div class="instructions">Arrastra para rotar • Haz clic en las troneras</div>

    <script>
        // Escena 3D
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 10, 50);

        // Cámara
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 12, 18);
        camera.lookAt(0, 0, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Eliminar loading
        document.getElementById('loading').style.display = 'none';

        // ILUMINACIÓN
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        const spotLight = new THREE.SpotLight(0xffeebb, 1.5);
        spotLight.position.set(0, 20, 5);
        spotLight.angle = Math.PI / 4;
        spotLight.penumbra = 0.5;
        spotLight.decay = 2;
        spotLight.distance = 50;
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.width = 2048;
        spotLight.shadow.mapSize.height = 2048;
        scene.add(spotLight);

        const rimLight = new THREE.DirectionalLight(0xd4af37, 0.5);
        rimLight.position.set(-10, 10, -10);
        scene.add(rimLight);

        // MATERIALES
        const feltMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a4d2e,
            roughness: 0.9,
            metalness: 0.1,
        });

        const woodMaterial = new THREE.MeshStandardMaterial({
            color: 0x3d2817,
            roughness: 0.7,
            metalness: 0.2,
        });

        const rubberMaterial = new THREE.MeshStandardMaterial({
            color: 0x0a0a0a,
            roughness: 0.6,
            metalness: 0.1,
        });

        const pocketMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.4,
            metalness: 0.6,
        });

        const ballMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            roughness: 0.1,
            metalness: 0.1,
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
        });

        // MESA DE BILLAR
        const tableGroup = new THREE.Group();

        // Tablero (fieltro)
        const boardGeometry = new THREE.BoxGeometry(14, 0.3, 7);
        const board = new THREE.Mesh(boardGeometry, feltMaterial);
        board.position.y = 0.15;
        board.receiveShadow = true;
        tableGroup.add(board);

        // Marco de madera (alrededor)
        const frameThickness = 0.8;
        const frameHeight = 0.6;

        // Marco - Lados largos
        const frameLongGeometry = new THREE.BoxGeometry(15.6, frameHeight, frameThickness);
        const frameLong1 = new THREE.Mesh(frameLongGeometry, woodMaterial);
        frameLong1.position.set(0, 0.3, 3.9);
        frameLong1.castShadow = true;
        frameLong1.receiveShadow = true;
        tableGroup.add(frameLong1);

        const frameLong2 = frameLong1.clone();
        frameLong2.position.set(0, 0.3, -3.9);
        tableGroup.add(frameLong2);

        // Marco - Lados cortos
        const frameShortGeometry = new THREE.BoxGeometry(frameThickness, frameHeight, 8.6);
        const frameShort1 = new THREE.Mesh(frameShortGeometry, woodMaterial);
        frameShort1.position.set(7.9, 0.3, 0);
        frameShort1.castShadow = true;
        frameShort1.receiveShadow = true;
        tableGroup.add(frameShort1);

        const frameShort2 = frameShort1.clone();
        frameShort2.position.set(-7.9, 0.3, 0);
        tableGroup.add(frameShort2);

        // Bandas de goma
        const cushionHeight = 0.5;
        const cushionThickness = 0.4;

        // Cojines largos
        const cushionLongGeometry = new THREE.BoxGeometry(14, cushionHeight, cushionThickness);
        const cushionLong1 = new THREE.Mesh(cushionLongGeometry, rubberMaterial);
        cushionLong1.position.set(0, 0.55, 3.5);
        cushionLong1.castShadow = true;
        tableGroup.add(cushionLong1);

        const cushionLong2 = cushionLong1.clone();
        cushionLong2.position.set(0, 0.55, -3.5);
        tableGroup.add(cushionLong2);

        // Cojines cortos
        const cushionShortGeometry = new THREE.BoxGeometry(cushionThickness, cushionHeight, 7);
        const cushionShort1 = new THREE.Mesh(cushionShortGeometry, rubberMaterial);
        cushionShort1.position.set(7, 0.55, 0);
        cushionShort1.castShadow = true;
        tableGroup.add(cushionShort1);

        const cushionShort2 = cushionShort1.clone();
        cushionShort2.position.set(-7, 0.55, 0);
        tableGroup.add(cushionShort2);

        // Patas de la mesa
        const legGeometry = new THREE.CylinderGeometry(0.4, 0.3, 4, 16);
        const legPositions = [
            [-6, -2, -2.5], [6, -2, -2.5],
            [-6, -2, 2.5], [6, -2, 2.5]
        ];

        legPositions.forEach(pos => {
            const leg = new THREE.Mesh(legGeometry, woodMaterial);
            leg.position.set(pos[0], pos[1], pos[2]);
            leg.castShadow = true;
            tableGroup.add(leg);
        });

        // TRONERAS
        const pocketGeometry = new THREE.CylinderGeometry(0.5, 0.4, 0.6, 16);
        const pockets = [];
        const pocketPositions = [
            { pos: [-7, 0.5, -3.5], id: 'tl' },
            { pos: [0, 0.5, -3.5], id: 'tc' },
            { pos: [7, 0.5, -3.5], id: 'tr' },
            { pos: [-7, 0.5, 3.5], id: 'bl' },
            { pos: [0, 0.5, 3.5], id: 'bc' },
            { pos: [7, 0.5, 3.5], id: 'br' }
        ];

        pocketPositions.forEach((pocketData, index) => {
            const pocket = new THREE.Mesh(pocketGeometry, pocketMaterial);
            pocket.position.set(pocketData.pos[0], pocketData.pos[1], pocketData.pos[2]);
            pocket.userData = { id: pocketData.id, index: index };
            pockets.push(pocket);
            tableGroup.add(pocket);
        });

        // BOLA BLANCA
        const ballGeometry = new THREE.SphereGeometry(0.25, 32, 32);
        const cueBall = new THREE.Mesh(ballGeometry, ballMaterial);
        cueBall.position.set(0, 0.4, 0);
        cueBall.castShadow = true;
        tableGroup.add(cueBall);

        // Líneas de la mesa
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.3, transparent: true });
        
        // Línea central
        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0.16, -3.5),
            new THREE.Vector3(0, 0.16, 3.5)
        ]);
        const centerLine = new THREE.Line(lineGeometry, lineMaterial);
        tableGroup.add(centerLine);

        // Línea horizontal
        const hLineGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(-7, 0.16, 0),
            new THREE.Vector3(7, 0.16, 0)
        ]);
        const horizontalLine = new THREE.Line(hLineGeometry, lineMaterial);
        tableGroup.add(horizontalLine);

        // Círculo central
        const circleGeometry = new THREE.RingGeometry(0.4, 0.42, 32);
        const circleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.3, transparent: true, side: THREE.DoubleSide });
        const centerCircle = new THREE.Mesh(circleGeometry, circleMaterial);
        centerCircle.rotation.x = -Math.PI / 2;
        centerCircle.position.set(0, 0.16, 0);
        tableGroup.add(centerCircle);

        scene.add(tableGroup);

        // CONTROLES DE CÁMARA (Mouse)
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraAngle = 0;
        let cameraHeight = 12;
        let cameraRadius = 18;

        document.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaMove = {
                    x: e.clientX - previousMousePosition.x,
                    y: e.clientY - previousMousePosition.y
                };

                cameraAngle -= deltaMove.x * 0.01;
                cameraHeight += deltaMove.y * 0.05;
                cameraHeight = Math.max(5, Math.min(20, cameraHeight));

                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        // Touch events para móvil
        document.addEventListener('touchstart', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });

        document.addEventListener('touchend', () => {
            isDragging = false;
        });

        document.addEventListener('touchmove', (e) => {
            if (isDragging) {
                const deltaMove = {
                    x: e.touches[0].clientX - previousMousePosition.x,
                    y: e.touches[0].clientY - previousMousePosition.y
                };

                cameraAngle -= deltaMove.x * 0.01;
                cameraHeight += deltaMove.y * 0.05;
                cameraHeight = Math.max(5, Math.min(20, cameraHeight));

                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        });

        // Click en troneras
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(pockets);

            if (intersects.length > 0) {
                const pocket = intersects[0].object;
                const pocketId = pocket.userData.id;
                
                // Animar bola hacia la tronera
                animateBallToPocket(pocket.position);
            }
        }

        function animateBallToPocket(targetPosition) {
            const startPosition = cueBall.position.clone();
            const duration = 800;
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = 1 - Math.pow(1 - progress, 3);

                cueBall.position.lerpVectors(startPosition, targetPosition, easeProgress);
                cueBall.position.y = 0.4 + Math.sin(progress * Math.PI) * 0.1;

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Caer en la tronera
                    cueBall.scale.setScalar(1 - progress);
                    setTimeout(() => {
                        // Redireccionar según tronera
                        const pocketId = pockets.find(p => p.position.equals(targetPosition))?.userData.id;
                        if (pocketId === 'tl' || pocketId === 'tc') {
                            window.location.href = pocketId === 'tl' ? 'reglas/' : 'elo/';
                        }
                    }, 300);
                }
            }

            animate();
        }

        document.addEventListener('click', onMouseClick);
        document.addEventListener('touchend', (e) => {
            mouse.x = (e.changedTouches[0].clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.changedTouches[0].clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(pockets);

            if (intersects.length > 0) {
                const pocket = intersects[0].object;
                animateBallToPocket(pocket.position);
            }
        });

        // ANIMACIÓN
        function animate() {
            requestAnimationFrame(animate);

            // Actualizar posición de cámara
            camera.position.x = Math.sin(cameraAngle) * cameraRadius;
            camera.position.z = Math.cos(cameraAngle) * cameraRadius;
            camera.position.y = cameraHeight;
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        animate();

        // Responsive
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
